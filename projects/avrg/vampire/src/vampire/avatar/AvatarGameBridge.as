package vampire.avatar{import com.threerings.flash.MathUtil;import com.threerings.util.Log;import com.whirled.AvatarControl;import com.whirled.ControlEvent;import com.whirled.EntityControl;import com.whirled.contrib.EventHandlerManager;import flash.events.Event;import vampire.data.VConstants;/** * Monitors other room entities and reports to the AVRG game client * the closest avatar (not necessarily playing the game). * */public class AvatarGameBridge{    /**    *    * applyColorScheme: a function to change the avatar color state.    *   e.g. applyColorScheme( Constants.COLOR_SCHEME_VAMPIRE)    */    public function AvatarGameBridge( ctrl :AvatarControl)    {        _ctrl = ctrl;        Log.setLevel("vampire.avatar.VampireBody", Log.ERROR);        //Only the controlling instance updates, listens to events, and has custom properties.        if( _ctrl.hasControl()) {            _ctrl.registerPropertyProvider(propertyProvider);            _events.registerListener(_ctrl, ControlEvent.ENTITY_MOVED, handleEntityMoved);        }        _events.registerListener(_ctrl, Event.UNLOAD, handleUnload);    }    protected function propertyProvider(key :String) :Object    {//        trace("propertyProvider(" + key + ")");        switch( key ) {            case ENTITY_PROPERTY_SETSTATE_FUNCTION:                return setState as Object;            case ENTITY_PROPERTY_SET_STAND_BEHIND_ID_FUNCTION:                return setAvatarIdToStandBehind as Object;            case ENTITY_PROPERTY_IS_LEGAL_AVATAR:                return true;            case ENTITY_PROPERTY_SET_AVATAR_ARRIVED_CALLBACK:                return setArrivedCallback as Object;           default:                return null;        }    }    protected function setAvatarIdToStandBehind( targetId :int) :void    {        _avatarIdToStandBehind = targetId;    }    protected function setState( newState :String ) :void    {        _ctrl.setState( newState );    }    protected function handleUnload( ...ignored ) :void    {        _events.freeAllHandlers();        _avatarArrivedCallback = null;    }    protected function handleEntityMoved (e :ControlEvent) :void    {        if( !_ctrl.hasControl()) {            return;        }        //We only care about avatars.        if( _ctrl.getEntityProperty( EntityControl.PROP_TYPE, e.name) != EntityControl.TYPE_AVATAR) {            return;        }        var userIdMoved :int = int(_ctrl.getEntityProperty( EntityControl.PROP_MEMBER_ID, e.name));        //We only care about our own avatar        if( userIdMoved != playerId ) {            return;        }        var userHotspot :Array = _ctrl.getEntityProperty( EntityControl.PROP_HOTSPOT, e.name) as Array;        //e.value == null means the avatar has arrived at it's location.        if (e.value == null) {//Only compute closest avatars when this avatar has arrived at location            //We only report the non-players, as the game knows where the players are            var actualLocation :Array = _myLocation;            _myLocation = null;            //Notify listeners that we have arrived at our destination            if( userIdMoved == playerId ) {//                trace(playerId + " avatar thinks we have arrived at our destination, loc=" + _myLocation + ", e=" + e);                if( _avatarArrivedCallback != null) {                    if( _turningToPreysAngle) {                        _turningToPreysAngle = false;                    }                    else {                        _avatarArrivedCallback(actualLocation);                    }                }                //And adjust our angle to our targets, if we have a target                //If our location is the same as our targets, we have the same orientation                //otherwise, we want to face our target                if( _avatarIdToStandBehind > 0 ) {                    var targetEntityId :String = getEntityId( _avatarIdToStandBehind );                    var targetLocation :Array = _ctrl.getEntityProperty( EntityControl.PROP_LOCATION_LOGICAL, targetEntityId) as Array;                    //If we are not the first predator, standing slightly behind the target, make                    //sure we are facing the same orientation as th target.  If we aren't the first                    //pred, face the target                    var distance :Number = MathUtil.distance( actualLocation[0], actualLocation[2], targetLocation[0], targetLocation[2] );                    _turningToPreysAngle = true;                    if( distance <= MINIMUM_FIRST_TARGET_DISTANCE ) {                        var targetorientation :Number = Number(_ctrl.getEntityProperty(                            EntityControl.PROP_ORIENTATION, targetEntityId));                        _ctrl.setLogicalLocation(actualLocation[0], actualLocation[1], actualLocation[2], targetorientation );                    }                    else {                        var faceTargetOrientation :Number = targetLocation[0] < actualLocation[0] ? 270 : 90;                        _ctrl.setLogicalLocation(actualLocation[0], actualLocation[1], actualLocation[2], faceTargetOrientation );                    }                    //Reset our target                    _avatarIdToStandBehind = -1;                }            }            if( actualLocation == null ) {                actualLocation = _ctrl.getEntityProperty( EntityControl.PROP_LOCATION_LOGICAL, e.name) as Array;                if(actualLocation) {                    actualLocation = actualLocation.slice();                }            }        }        else {            //Because when the entity arrives, the locaiton info is stale, this holds a record of the correct location.            var entityLocation :Array = e.value as Array;            _myLocation = entityLocation.slice();        }    }    protected function get playerId() :int    {        return int(_ctrl.getEntityProperty(EntityControl.PROP_MEMBER_ID));    }    protected function getEntityId( userId :int ) :String    {        for each( var entityId :String in _ctrl.getEntityIds(EntityControl.TYPE_AVATAR)) {            var entityUserId :int = int(_ctrl.getEntityProperty( EntityControl.PROP_MEMBER_ID, entityId));            if( userId == entityUserId) {                return entityId            }        }        return null;    }    protected function setArrivedCallback( callback :Function ) :void    {        _avatarArrivedCallback = callback;    }    protected var _myLocation :Array;    protected var _ctrl :AvatarControl;    protected var _avatarArrivedCallback :Function;    protected var _avatarIdToStandBehind :int = -1;    /**Don't send an event when turning to the prey.*/    protected var _turningToPreysAngle :Boolean = false;    protected var _events :EventHandlerManager = new EventHandlerManager();    /**For providing a function to change avatar states*/    public static const ENTITY_PROPERTY_SETSTATE_FUNCTION :String = "SetStateFunction";    /**For providing a function to change avatar states*/    public static const ENTITY_PROPERTY_SET_STAND_BEHIND_ID_FUNCTION :String = "SetStandBehind";    /** You must wear a level avatar to play the game */    public static const ENTITY_PROPERTY_IS_LEGAL_AVATAR :String = "IsLegalVampireAvatar";    /**    * Provide a function that takes as an argument another function.  We store the function    * argument and call it when we arrive a a destination.    */    public static const ENTITY_PROPERTY_SET_AVATAR_ARRIVED_CALLBACK :String = "ArrivedCallback";    /**    * When this avatar arrives at it's destination, and it has a target, check how far away    * we are from the target location.  If we are below this distance, we must be the first    * predator (standing directly behind the target).  If we are greater than this distance,    * we must have our orientation changed to face the target.    */    public static const MINIMUM_FIRST_TARGET_DISTANCE :Number = MathUtil.distance(0, 0, VConstants.FEEDING_LOGICAL_X_OFFSET, VConstants.FEEDING_LOGICAL_Z_OFFSET) + 0.01;    protected static const log :Log = Log.getLog( AvatarGameBridge );}}